ejb2 和 ejb3的区别
EJB 3 和EJB 2.1 的区别 

从整个EJB 规范的角度来说，EJB 3 和EJB 2.1最大变更在Entity Bean 持久化 
API 上。在EJB3 中，Entity Bean持久化已经单独作为一个Persistence API 
规范和其他的EJB 部分分离开来。下面我们主要讨论EJB 3 和EJB 2.1在持久化 
API 上的区别。 

EJB 2.1模型存在复杂度高的缺陷： 
EJB 2.0 模型要求创建多个组件接口并实现多个不必要的回调方法组件接口要求实现 EJBObject 或 EJBLocalObject 以及处理许多不必要 的异常 

基于XML 的EJB 2.0 部署描述符比较复杂并容易出错 

基于 EJB 模型的容器管理持久性在开发和管理方面过于复杂，并且失去了几个基本 特性--如使用数据库序列定义主键的标准方法 

EJBQL 语法非常有限，而且是静态的，无法做到运行期间的动态查询 

EJB 2.0 组件并非是真正面向对象的，因为它们在继承和多态性方面的有 
使用限制开发人员无法在 EJB 容器外部测试 EJB 模块，而在容器内部调试 EJB非常复杂和耗时查 和调用 EJB 2.0 是一项复杂的任务。即使是在应用程序中使用最基本的 EJB 也需要对 JNDI 有一个详细的了解对容器的依赖使得EJB 2.0只能用于服务器组件的开发，无法实现一次编写，四处运行的面向构件的开发所有这些复杂度和缺陷，都导致EJB 2.0的采用无法真正简化开发并提高生产力。 

EJB 3.0 旨在解决以往EJB 2.0 模型的复杂性和提高灵活性，具体体现在： 

消除了不必要的接口Remote, Home, EJB 以及回调方法实现 

实体Bean 采用了POJO模型，一个简单的javabean 就可以是一个EntityBean。无需依赖容器运行和测试 

全面采用O/R Mapping技术来实现数据库操作实体Bean 可以运用在所有需要持久化的应用，不管是客户端还是服务器端。从而真正实现面向构件的开发实体 bean 现在支持继承和多态性 

灵活丰富的EJB3 查询语言SQL支持 
使用元数据批注代替部署描述符，减少复杂配置和提高可维护性 
将常规 Java 类用作 EJB 并将常规业务接口用于 EJB 

EJB 3 中的元数据批注:Annotation 

EJB3 规范中引入了元数据批注(Annotation)。Annotation 是从J2SE 1.5 始 
称为java语言的一部分。Annotation 并不是一个新的事物，在J2SE 1.5 以前， 
人们已经自行引入了象著名的XDoclet 等外挂式的元数据批注方法。而在.NET 
中，元数据批注也早已经是C#语言的成分了。 
在以往，我们都是采用xml 作为配置批注，但采用文本的xml配置存在一些缺陷： 
描述符多，不容易记忆和掌握 
无法做自动的校验，需要人工排错 
当系统变大时，大量的xml配置难以管理 
读取和解析xml配置非常耗时，导致应用启动缓慢，不利于测试和维护 
做O/R Mapping 的时候需要在java 文件和xml 配置文件之间交替，增大 
了工作量 
运行中保存xml配置需要消耗额外的内存 

采用元数据可以很好的解决这些问题: 

描述符大量减少。以往在xml配置中往往需要描述java属性的类型，关 
系等等。而元数据本身就是java语言，从而省略了大量的描述符 
编译期校验。错误的批注在编译期间就会报错。 
元数据批注在java代码中，避免了额外的文件维护工作 
元数据被编译成java bytecode，消耗小的多内存，读取也非常迅速，往 
往比xml配置解析快几个数据量级，利于测试和维护 
